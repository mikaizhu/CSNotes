# 目录
<!--ts-->
* [目录](#目录)
* [操作系统](#操作系统)
* [第一回](#第一回)
* [第二回](#第二回)
* [第三回](#第三回)
* [第四回](#第四回)
* [第五回](#第五回)
* [第六回](#第六回)
* [第七回](#第七回)

<!-- Added by: zwl, at: Thu Jul 14 18:50:09 CST 2022 -->

<!--te-->
# 操作系统

推荐教程：
- [哈工大操作系统 [MOOC]](https://www.icourse163.org/learn/HIT-1002531008?tid=1450346461#/learn/content?type=detail&id=1214728532&cid=1218670721&replay=true) 
- [哈工大操作系统
  [bilibili]](https://www.bilibili.com/video/BV1d4411v7u7?from=search&seid=8612787840369428117&spm_id_from=333.337.0.0) 
- [品读操作系统源码](https://github.com/sunym1993/flash-linux0.11-talk#%E5%B7%B2%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0) 


[【↥ back to top】](#目录)
# 第一回

在电脑开机到启动，经历了下面几个过程：
- 开机的时候，电脑主板上写死的BIOS(Basic Input Output System)程序会自动运行
- BIOS会将存储在硬盘上的操作系统，拷贝到内存的0x7c00，这个地址由电脑架构决定
- 电脑从该地址开始，一行一行执行命令

> 注意：
>
> 1. 操作系统肯定是先存储在硬盘中的
>
> 2. 代码执行肯定是在内容中的，并且执行方式为**取指执行** 
>
> 3. 该部分bootsect.s 汇编文件控制
>
> 4. ds寄存器的值为0x07c0，之后的代码，段基地址都要先左移动4位，这就变成了0x7c00,
> 所以之后的9000->90000都是这个原理,
> ds是段基寄存器，后面的地址都是在这个基础上偏移

> 为什么要左移4位呢？
>
> 因为此时x86为16位实模式, 为了能访问到20位的地址线，所以要左移4位

[reference](https://mp.weixin.qq.com/s/LIsqRX51W7d_yw-HN-s2DA) 


[【↥ back to top】](#目录)
# 第二回

从上回开始，开机后，操作系统开始执行命令了，命令如下：
- 将各个寄存器赋值[ds:0x07c0, es:0x9000, cx:256, si:0, di:0]
- 将ds开始的512字节(cx * 2)的内容，复制到0x90000处(为啥是512字节？`rep movw`
  命令表示复制一个字，每个字是16位，也就是2字节，重复该命令256次，)
- 程序 跳转至go标记处，也就是0x9000 + go标记的偏移地址开始执行剩下的代码
可以看到，第二回的代码就是将程序移动了个位置，将内容腾出空间来了

> 内存复制是从(ds:si --> es:di)

[reference](https://mp.weixin.qq.com/s/U-txDYt0YqLh5EeFOcB4NQ) 


[【↥ back to top】](#目录)
# 第三回

在执行代码之前，因为所有的工作都是在内存中执行的，为了方便管理，要对内存的使用进行一个规划：
- 给寄存器赋值(cs:0x9000, ds:0x9000, ss:0x9000, es:0x9000, ip:0x9000, sp:0xFF00)
- 前面我们将代码挪动到了0x90000处，栈由指针控制，所以栈顶为0x9FF00

现在内存中寄存器布局位置如下：

```
栈顶 ss:sp   -->   0x9FF00 |    |
                           |    |
                           |    |
                           |    |
                           |    |
ss,ds,cs,ip,es --> 0x90000 |    |
```

> 1. 内存中很重要的三个片段: cs为代码段，ds为数据段，ss堆栈段, es为附加段，ip为指令指针
>
> 2. cs + ip 控制代码访问, ss + sp控制栈顶访问， ds控制数据访问， es先不用理会
>
> 3. 栈的位置要远远大于代码的位置0x90000，所以设置为0x9FF00,
>    保证栈向下发展不会碰到其他段

> 1. 该部分就是将各个寄存器设置好了值
> 2. 再抽象点就是：该部分给如何访问代码，如何访问数据，如何访问栈进行了内存的初步规划

[reference](https://mp.weixin.qq.com/s/90QBJ-lP_-du2qQJxNF-Fw) 


所以，该部分 `bootsect.s`代码，所做的就是对内存做了初步规划


[【↥ back to top】](#目录)
# 第四回

上面代码中，代码已经做了：
1. 将启动部分代码从硬盘中第一扇区搬到了内存中
2. 对内存的使用做了初步的规划，代码段，数据段，堆栈段

**注意**: 此时我们还在`bootsect.s`文件中

接下来还有操作系统的其他代码，要从硬盘搬到内存中:
- 程序发起中断, 执行其他代码,
  该代码会将2-5一共4个扇区的代码，拷贝到0x90200往后的部分，因为每个扇区都是512字节，刚好是200表示，0x90400这样一直往后拷入代码。
- 从第6个扇区开始的代码，拷贝到内存的0x10000处
- 最后跳转到0x90200代码处开始执行

重新梳理下：
- 0x90000-0x90200部分代码，装的是bootsect.s，即第1扇区的代码
- 0x90200-0x90A00部分，装的是setup.s部分，即第2-5扇区
- 0x10000往后，装的是第6往后240个扇区的代码，为system

> 中断是什么？
>
> 中断包括三种：
>
> 1）I/O设备的中断 
>
> 2）程序异常的中断 
>
> 3）INT信号的中断
>
> 前两种中断都是硬件的中断, 如鼠标点击，键盘输入为1)中断, 寄存器中的计算错误为2）中断，最后一种为软件的中断，如SIG中断，9表示HANP信号，相当于kill -s 9 <pid>
>
> [中断参考文章](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247498208&idx=1&sn=b784f8b4e627ebd1bfb9810d194fdb80&chksm=c2c5834df5b20a5bdee331002bfc61c90eb468da325bf67abeef780c303a9f51c8543e1a5981&scene=21#wechat_redirect) 

**总结下前面部分都是`bootsect.s` 文件的工作内容，工作内容如下**:
1. 刚启动的时候，刻入在板子上的BIOS代码，会将硬盘中的第一扇区代码，寸到内存中，然后开始执行(只要我们将bootsect.s代码，编译到这部分地址即可)
2. 对内存进行初步规划
3. 将setup部分代码，存储到内存中
4. 将操作系统代码，存储到内存中，3.4部分说明就是将剩下的代码，也从硬盘中搬运到内存中


[【↥ back to top】](#目录)
# 第五回

前面讲完了`bootsect.s`部分的代码，现在可以进入到`setup.s`，该部分代码做了如下几件事:
- 通过各种中断调用(其实就相当于调用函数，然后将获取的值，存储到寄存器中),
  获取电脑各种硬件的值，如显存大小，内存大小等
- 将这些信息存储到0x90000的位置
- 然后将0x10000部分260个扇区的代码(即system部分，这部分代码相当于整个操作系统文件编译出来的)， 复制移动到内存地址为0开始的部分

于是，现在整个内存的规划如下：

```
栈顶 0x9FF00         |     |
                     |     |
                     |     |
setup 0x90200        |     | <--  setup.s就是将电脑信息获取并存储，同时对内存进行了管理
                     |     |
电脑信息存储 0x90000 |     |
                     |     |
   0x80000           |     | <--  到这个部分都是存储的操作系统，刚好512K，大约512 * 1024 字节
   操作系统          |     |
   0x0               |     |
```

[reference](https://mp.weixin.qq.com/s/5s_nmrWRZbA_4mkNKOQ2Cg) 


[【↥ back to top】](#目录)
# 第六回

这一讲介绍了intel芯片的一个历史遗留问题，前面我们知道`ds`
为段基寄存器，其与内存中地址的转换方法为**段基地址左移4位，然后与偏移地址相加，最后获得实际的地址** 

上面这种计算方式为：实模式，也就是16位实模式下的CPU，然而现在很多CPU都支持32位或者64位

当切换到保护模式下后，内存地址的计算方式就不同: 段选择子 --> 段描述符索引 -->
查表(gdt全局描述符表) --> 获得段描述符 --> 段基地址 --> 与偏移地址相加，获得实际物理地址

> 总的来说，就是ds寄存器，在保护模式下，里面存储的不叫段基址，而叫段选择子，段选择子中存储着**段描述符索引**
> 既然是索引，那么就可以查表，获得对应的值了，然后从存储在内存中的全局描述符表中，查找到段描述符。段描述符中含有段基地址，也就是实模式下的ds存储的段基地址，最后与偏移地址相加。
> 所以，保护模式下，最后也是为了获得段基地址，只不过多了很多中间步骤.

这一讲就是介绍了在进入保护模式的时候，内存地址的查询变复杂了，设置了一个中间层，现在需要查表(gdt)才能获得真实地址了

```
栈顶 0x9FF00         |     |
                     |     | <--  idt地址(中断描述表 也存储在setup这部分中)
                     |     | <--  gdt地址(全局描述表 存储在setup这部分地址中)
setup 0x90200        |     | <--  setup.s就是将电脑信息获取并存储，同时对内存进行了管理
                     |     |
电脑信息存储 0x90000   |     |
                     |     |
   0x80000           |     | <--  到这个部分都是存储的操作系统，刚好512K，大约512 * 1024 字节
   操作系统           |     |
   0x0               |     |
```

> 什么是实模式？最开始，cpu都是直接操作内存地址，这种叫做实模式，否则叫保护模式
> 保护模式可以给这个代码段设置权限，比如可读，可写，不可读等
> 这部分还设置了中断描述符表idt, 中断代码查询，然后跳转执行
> gdt分为代码段和数据段描述符

[reference](https://mp.weixin.qq.com/s/p1a6QxYZyMpJF__uBSE1Kg) 


[【↥ back to top】](#目录)
# 第七回

进入保护模式很简单，直接将cr0寄存器中的地位设置为1，计算机就进入了保护模式。

保护模式下，寻址都是通过查看寄存器中段选择子中的段描述符，然后通过段描述符，去内存中的全局描述符中查找对应的段基址，查看发现这是个可以读可以执行的地址，然后跳转到这个位置，加上偏移，最后执行。

这部分最后跳转到内存地址为0的位置，开始执行head.s，准备进入操作系统。

[reference](https://mp.weixin.qq.com/s/S5zarr9BmLhUHAmdmeNypA) 

# 第八回

这一讲就是再设置一遍gdt和idt，将两个描述符的位置，从之前的setup里面，迁移到了system里面，因为后面上面的其他内存会被覆盖掉。

同时给每个中断，都设置了一个默认的指向函数，ignore函数，到时候会替换这个指向。

# 第九回

这一回就是通过设置寄存器的标志位，手动开启分页操作。

开启分页操作前，我们是通过分段的方式，来进行物理地址的转换。

开启分页操作后，通过段获取的是虚拟内存地址。通过查询页表后，才能转换成物理地址。

CPU 在看到我们给出的内存地址后，首先把线性地址被拆分成, 高 10 位：中间 10 位：后 12 位,  高 10 位负责在页目录表中找到一个页目录项，这个页目录项的值加上中间 10 位拼接后的地址去页表中去寻找一个页表项，这个页表项的值，再加上后 12 位偏移地址，就是最终的物理地址。

而这一切的操作，都由计算机的一个硬件叫 MMU，中文名字叫内存管理单元，有时也叫 PMMU，分页内存管理单元。由这个部件来负责将虚拟地址转换为物理地址。

# 第十回

就是将main函数的代码，压入到栈中，然后让cpu去执行

# 第十二回

开始进入main函数，最开始还是内存管理，设置了主内存的开始末尾位置，以及缓冲区的位置。

# 第十三回

就是设置了一个数组来进行内存管理(mem_map函数)，将内存进行分页，每页的大小为4k，所以数组的每个元素表示4k内存.

# 第十四回

这一回主要介绍了什么时候键盘可以工作，键盘本质上是中断，这里代码重新写入了中断，并一项项添加进idt中，其中键盘的中断，是后面定义的，有部分中断为硬件代码初始化的时候创建的.

# 第十五回

操作系统是如何读取硬盘的, 在进入main函数开始的时候，会初始化一个request请求的结构体，这个结构体就是一个列表，如果有进程需要和内存通信，最后就会形成一个链表，这个链表记录了所有请求.最后操作系统会处理所有的请求，清空链表

# 第十六回

就是介绍了下如何向屏幕写入数据。首先我们要知道，内存中的一部分空间，是映射的显存。只要往内存这部分写入数据，就是往显存上写入数据，然后屏幕上就会显示内容。

关键的一点就是光标位置。要确定光标位置，需要三个参数。x，y，pos(pos是根据x和y计算出来的显存的位置, 所以我们还可以设置换行操作)，x表示光标所在行号，y表示光标所在列号，pos表示要写入的内存地址。显存有两个部分，第一个部分表示要写入的内容，第二个部分为内容的颜色。如果要做到向屏幕显示内容，先要获取光标位置，然后触发中断，将键盘中断获取的内容，填入到光标的内存中，然后光标的内存进行移动。

甚至我们还可以做到屏幕滚动。其实就是将显存内容进行复制。

# 第十七回

操作系统是如何设置时间的？以前还没有网络的时候，电脑是如何获取时间的。本质上还是操作系统写了一个和外部硬件通信的函数，从外界获取，并计算出时间。获取的方式主要为。每个硬件都有自己的手册，说明了每个端口要设置什么参数，如何读取。我们只要按照手册上的参数设置就好了。操作系统就是和外部的CMOS进行交互，获取到了当前时间。

# 第十八回

这一讲主要介绍了三个主要内容：
1. 往全局描述符gdt中加入了两个新的角色，TSS和LDT，其中LDT是局部描述符，里面有自己的数据段和代码段，以后用户进程都用自己的LDT，而TSS为任务状态段，保存的进程的上下文信息，内部为结构体，保存的各个寄存器的信息。用来帮助恢复上下文。这两个信息都是加入在全局描述符后面的。代码中先为0进程的创建，先添加了TSS和LDT，其他的初始化为空。

2. 创建了一个task struct数据结构（结构体）,用来保存每个进程的信息。类似于数组一样，并给第0个进程进行初始化，其他的进程设置为空，以后添加。

3. 设置了两个中断函数，时钟中断timer interrupt和system call系统调用中断。这两个中断非常重要，时钟中断是方便进程切换，利用外部的时钟信息，发起时钟中断，然后调用中断函数。系统调用是当系统想使用系统函数，就会触发该中断，从用户态切换到内核态。

# 第十九回

这里设置了缓存区的初始化。内存中有部分叫buffer memory，以后操作系统要和硬盘交互的时候，都会先和缓存区进行交互，判断数据是不是有了，如果有，就不用读取了。

管理的方式，是使用双链表，结构体中，含有两个部分，缓冲块和缓冲头，缓冲头有缓冲块的地址，缓冲块是存储数据的。缓冲头采用的是双链表的数据结构，同时指向缓冲块的地址。

但链表有个缺点，就是必须要每次都从头开始遍历。所以还构造一个hash table，当数据过来的时候，可以通过哈希值，看是不是有冲突，表示数据是不是已经有了。

# 第二十回

**看到最后，你会发现操作系统就是一个靠中断驱动的死循环而已，如果不发生任何中断，操作系统会一直在一个死循环里等待。换句话说，让操作系统工作的唯一方式，就是触发中断。**

这一回介绍了硬盘的初始化，简单来说只有三步：
1. 向硬盘写入数据，表示要进行什么操作
2. 新建一个硬盘中断函数, 硬盘中断触发，就会执行这个中断
3. 定义数据结构，来管理读取的数据

# 中期总结

[参考](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247500983&idx=1&sn=ad4c430823c975df97f13de3fbe8c66e&chksm=c2c5be1af5b2370cad4ce3218c5294feee4ae2e4d28804398c1dc8ac252c8dfafbe419ccf58c&cur_album_id=2123743679373688834&scene=189#wechat_redirect)

# 第二十一回

在前面进程初始化的时候，有一个task struct数据结构，这里定义了最开始的进程0，现在进入main函数后，从内核态切换到了用户态。然后执行fork命令，创建了第一个进程1，并且在里面执行init命令。init命令有很多代码，里面会创建进程2等。执行完init后，就会陷入循环，直到调用中断，操作系统才会做其他事。

# 第二十二回

mov_to_user_mode，特权级这块的检查细节非常繁琐，为了理解操作系统，我们只需要暂且记住如下一句话就好了：

数据访问只能高特权级访问低特权级，代码跳转只能同特权级跳转，要想实现特权级转换，可以通过中断和中断返回来实现。

# 第二十三回

进程调度的准备，如果要你设置一个进程调度，你会怎么操作。

为了保证上下文环境，需要保存各个寄存器的状态。

最主要的是下面几个。有表示状态的 state，表示剩余时间片的 counter，表示优先级的 priority，和表示上下文信息的 tss。其中tss中还有cr3，他是指向页表。意味着每个进程，都指向不同的页表，这样内存就不会冲突了。

# 第二十四回

罪魁祸首的，就是那个每 10ms 触发一次的定时器滴答。

而这个滴答将会给 CPU 产生一个时钟中断信号。

而这个中断信号会使 CPU 查找中断向量表，找到操作系统写好的一个时钟中断处理函数 do_timer。

do_timer 会首先将当前进程的 counter 变量 -1，如果 counter 此时仍然大于 0，则就此结束。

但如果 counter = 0 了，就开始进行进程的调度。

进程调度就是找到所有处于 RUNNABLE 状态的进程，并找到一个 counter 值最大的进程，把它丢进 switch_to 函数的入参里。

switch_to 这个终极函数，会保存当前进程上下文，恢复要跳转到的这个进程的上下文，同时使得 CPU 跳转到这个进程的偏移地址处。

接着，这个进程就舒舒服服地运行了起来，等待着下一次时钟中断的来临。

# 第二十五回

fork函数的调用过程，大致就是先从用户态切换到内核态。（通过中断0x80）

```
set_system_gate(0x80, &system_call);
```

看这个 system_call 的汇编代码，我们发现这么一行。

关键指令就是一个 0x80 号软中断的触发，int 80h。

其中还有一个 eax 寄存器里的参数是 __NR_fork，这也是个宏定义，值是 2。

```
_system_call:
    ...
    call [_sys_call_table + eax*4]
    ...
```

其中sys_call_table, 看到没，就是各种函数指针组成的一个数组，说白了就是个系统调用函数表。 从第零项开始数，第二项就是 sys_fork 函数

所以也可以直接调用 fork 这样的包装好的方法，而这个方法里本质也是 int 0x80 以及 eax 赋值而已。

那我们再多说两句，刚刚定义 fork 的系统调用模板函数时，用的是 syscall0，其实这个表示参数个数为 0，也就是 sys_fork 函数并不需要任何参数。

所以其实，在 unistd.h 头文件里，还定义了 syscall0 ~ syscall3 一共四个宏。

看都能看出来，其实 syscall1 就表示有一个参数，syscall2 就表示有两个参数。

整个流程：

fork->int 0x80|eax=2->system_call->syscall_table[2]->sys_fork;

# 第二十六回

这一讲主要介绍了sys_fork函数做了什么

其实就是调用了两个函数。

先是 find_empty_process，就是找到空闲的进程槽位。

然后 copy_process，就是复制进程。

就是先在这个数组中找一个空闲的位置，准备存一个新的进程的结构 task_struct，这个结构之前在 一个新进程的诞生（三）如果让你来设计进程调度 也简单说过了。

通过 copy_process 这个名字我们知道，就是复制原来的进程，也就是当前进程。

当前只有一个进程，就是数组中位置 0 处的 init_task.init，也就是零号进程，那自然就复制它咯。

find_empty_process主要做了以下：
1. 每个进程都是放在一个task数组中，进行管理的，每个数组都存放着一个结构体
2. 遍历task数组，查看当前元素是不是为空，不为空则继续查找当前pid是不是和使用的重复，重复则加一
3. 再使用一个for循环，判断当前taski是不是空，如果为空，则把新的进程结构体放入该位置, 并返回当前位置

由于我们现在只有 0 号进程，且 task[] 除了 0 号索引位置，其他地方都是空的，所以这个方法运行完，last_pid 就是 1，也就是新进程被分配的 pid 就是 1，然后即将要加入的 task[] 数组的索引位置，也是 1。

copy_process 方法

大部分都是 tss 结构的复制，以及一些无关紧要的分支

首先 get_free_page 会在主内存末端申请一个空闲页面, 那 get_free_page 这个函数就很简单了，就是遍历 mem_map[] 这个数组，找出值为零的项，就表示找到了空闲的一页内存。然后把该项置为 1，表示该页已经被使用。最后，算出这个页的内存起始地址，返回。然后，拿到的这个内存起始地址，就给了 task_struct 结构的 p。

首先将这个 p 记录在进程管理结构 task[] 中。
 
然后下一句 *p = *current 很简单，就是把当前进程，也就是 0 号进程的 task_struct 的全部值都复制给即将创建的进程 p，目前它们两者就完全一样了。嗯，这就附上值了，就完全复制之前的进程的 task_struct 而已，很粗暴。

然后，进程 1 和进程 0 目前是完全复制的关系，但有一些值是需要个性化处理的，下面的代码就是把这些不一样的值覆盖掉。不一样的值，一部分是 state，pid，counter 这种进程的元信息，另一部分是 tss 里面保存的各种寄存器的信息，即上下文。

# 第二十七回

主要讲得是copy_mem 函数;

那我们先看 LDT 表项的赋值，要说明白这个赋值的意义，得先回忆一下我们在 第九回 | Intel 内存管理两板斧：分段与分页 刚设置完页表时说过的问题。

因为有了页表的存在，所以多了线性地址空间的概念，即经过分段机制转化后，分页机制转化前的地址。

今后每个进程通过段基址的手段，分别在线性地址空间中占用 64M 的空间（暂不考虑段限长），且紧挨着。

经过以上的步骤，就通过分段的方式，将进程映射到了相互隔离的线性地址空间里，这就是段式管理。

原来进程 0 有一个页目录表和四个页表，将线性地址空间的 0-16M 原封不动映射到了物理地址空间的 0-16M。

那么新诞生的这个进程 2，也需要一套映射关系的页表，那我们看看这些页表是怎么建立的。这里需要一个copy_page_tables函数，这个函数比较复杂。做的工作主要是：
1. 前面利用分段机制，得到了虚拟地址。（分页机制开启后，分段后得到的，是虚拟地址）
2. 构建自己的页表，使得虚拟地址查表后，得到的是同样的物理地址

总之，最终的效果就是：

假设现在正在运行进程 0，代码中给出一个虚拟地址 0x03，由于进程 0 的 LDT 中代码段基址是 0，所以线性地址也是 0x03，最终由进程 0 页表映射到物理地址 0x03 处。

假设现在正在运行进程 1，代码中给出一个虚拟地址 0x03，由于进程 1 的 LDT 中代码段基址是 64M，所以线性地址是 64M + 3，最终由进程 1 页表映射到物理地址也同样是 0x03 处。

这样就实现了内存共享，虽然在分段机制上，每个进程都是64M分隔开来，但是通过分页后，可以操作共同的内存。但这样不就冲突了吗？后面可以实现缺页中断，使用的内存会被记录为可读状态。

总结下，copy_mem函数主要做了三个事：
1. LDT 的复制和改造，使得进程 0 和进程 1 分别映射到了不同的线性地址空间。
2. 页表的复制，使得进程 0 和进程 1 又从不同的线性地址空间，被映射到了相同的物理地址空间。
3. 最后，将新老进程的页表都变成只读状态，为后面写时复制的缺页中断做准备。

[参考](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247501866&idx=1&sn=64adec9179345945d095a1a1bdebcdac&chksm=c2c5b287f5b23b9175d8eacf7731b22823a576f78e14d8b93b2e8c9814bcb11076967d878a12&cur_album_id=2123743679373688834&scene=189#wechat_redirect)

# 第二十八回

这一讲主要总结了下，fork由0进程创建1进程的一个过程，后面1进程创建2进程的过程也是一样的。

首先fork通过0x80中断，调用system call函数，然后会进行查表，因为system call函数，会查找所有系统函数，都在一个table里面，然后调用第二个函数，对应是sys fork函数。这个函数里面有两个主要过程：
1. find empty process，从process table里面找空闲的位置
2. copy process函数，就是先复制当前进程的task struct给当前进程，然后修改下这个结构体里面的内容。（一般是修改寄存器里面的内容）同时还有修改数据段和代码段ldt，给每个进程分隔不同的线性地址（虚拟内存）。同时复制页表，并给进程2的tss页表，将新进程虚拟地址查询页表后，得到同样的物理地址。最后标记新进程为只读。

这里要主要：copy process函数在执行的时候，有个重要的细节就是，copy正在创建新进程的时候，一定要设置新进程的状态是无法选定的，因为里面还有很多没设置好，等设置好后，将状态修改为允许被调用。

[参考](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247501947&idx=1&sn=cb94f53c75d674d30fb4903778c74c08&chksm=c2c5b2d6f5b23bc027d9652d3e9949e55fd3b101beb87f6f80dd77d8233c0b51bede73edad46&cur_album_id=2123743679373688834&scene=189#wechat_redirect)

# 第二十九回

这一讲主要介绍了缺页中断：

页表当中有一位是表示读\写的，而 Linux 0.11 初始化时，把它设置为了 1，表示可读写。(即创建页表的时候，所有页表都是可读写的)

调用 fork 创建新进程时，原本页表和物理地址空间里的内容，都要进行复制, 但 fork 函数认为，复制物理地址空间里的内容，比较费时，所以姑且先只复制页表，物理地址空间的内容先不复制。

如果只有读操作，那就完全没有影响，复不复制物理地址空间里的内容就无所谓了，这就很赚。但如果有写操作，那就不得不把物理地址空间里的值复制一份，保证进程间的内存隔离。

fork的时候，两个进程都会指向同一个内存物理地址。并且映射的页表，都是只读状态。 那么此时，再次对这块物理地址空间进行写操作时，就不允许了。 但不允许并不是真的不允许，Intel 会触发一个缺页中断，具体是 0x14 号中断，中断处理程序里边怎么处理，那就由 Linux 源码自由发挥了。

假如是进程 2 写的。

显然此时这个物理空间被引用了大于 1 次，所以要复制页面。 并且更改页面只读属性为可读写。

```
new_page=get_free_page()；
*table_entry = new_page | 7;
```

那此时如果进程 1 再写, 那么引用次数就等于 1 了，只需要更改下页属性即可，不用进行页面复制操作。

```
if (mem_map[MAP_NR(old_page)]==1) ...
```

[参考](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502033&idx=1&sn=1acfd8b7f4c805906ecd51c33d0010eb&chksm=c2c5b27cf5b23b6a41051c7f93407afc97094a4b0a36ea050616778f4d072f074602f98983b2&cur_album_id=2123743679373688834&scene=189#wechat_redirect)

# 第四部分 三十回

这一回介绍了进程1创建后，只有进程1会执行的init命令。

在init命令中，最开始执行的就是读取硬盘信息了。

这一回主要介绍了两个事：
- 从内存中读取硬盘的信息，并保存在变量中。
- 从硬盘中，读取分区信息，保存到另一个变量中。(硬盘分区信息，被写在硬盘中的某个固定位置。要拿到这个位置的信息，我们要将硬盘中的某块数据，读取到内存中，然后在内存中获取)


# 第三十一回

[文件系统](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzk0MjE3NDE0Ng==&action=getalbum&album_id=2123743679373688834&scene=173&from_msgid=2247499274&from_itemidx=1&count=3&nolastread=1#wechat_redirect)

setup 函数，然后会调用sys_setup系统函数

这一回主要介绍了文件系统，文件系统是写好在硬盘中的，（注意有多种文件系统）如果操作系统和文件系统不匹配，那么操作系统是无法读取文件系统的。

文件系统其实就是一个数组和结构体的数据结构集合。我们只要按固定格式，每个位置放置什么内容，用超级块，块描述符号，inode表，保存信息即可。然后操作系统按顺序读取，获得目录结构。

第三十一回主要讲得就是，如何写代码，将已经写好在硬盘中的文件系统，读取到内存中。

注意根目录(mount_root函数)就是inode0结构体里，存储的信息，这个是写死的。

当我们读取了文件系统后，操作系统就可以读取硬盘中的所有数据了。

# 第三十二回

这一讲中利用之前 setup 加载过的根文件系统，通过 open 函数，根据文件名找到并打开了一个文件。

打开文件，返回给上层的是一个文件描述符，然后操作系统底层进行了一系列精巧的构造，使得一个进程可以通过一个文件描述符 fd，找到对应文件的 inode 信息。

其实，刚刚的 open 函数返回的为 0 号 fd，这个作为标准输入设备。

接下来的 dup 为 1 号 fd 赋值，这个作为标准输出设备。

再接下来的 dup 为 2 号 fd 赋值，这个作为标准错误输出设备。

那这个 dup 又是什么原理呢？非常简单，首先仍然是通过系统调用方式，调用到 sys_dup 函数。

那这个函数的逻辑非常单纯，就是从进程的 filp 中找到下一个空闲项，然后把要复制的文件描述符 fd 的信息，统统复制到这里。

那根据上下文，这一步其实就是把 0 号文件描述符，复制到 1 号文件描述符，那么 0 号和 1 号文件描述符，就统统可以通过一条路子，找到最终 tty0 这个设备文件的 inode 信息了。

此时进程 1 已经比进程 0 多了与 外设交互的能力，具体说来是 tty0 这个外设（也是个文件，因为 Linux 下一切皆文件）交互的能力，这句话怎么理解呢？什么叫多了这个能力？

因为进程 fork 出自己子进程的时候，这个 filp 数组也会被复制，那么当进程 1 fork 出进程 2 时，进程 2 也会拥有这样的映射关系，也可以操作 tty0 这个设备，这就是“能力”二字的体现。

而进程 0 是不具备与外设交互的能力的，因为它并没有打开任何的文件，filp 数组也就没有任何作用。

进程 1 刚刚创建的时候，是 fork 的进程 0，所以也不具备这样的能力，而通过 setup 加载根文件系统，open 打开 tty0 设备文件等代码，使得进程 1 具备了与外设交互的能力，同时也使得之后从进程 1 fork 出来的进程 2 也天生拥有和进程 1 同样的与外设交互的能力。


# 第三十三回

这一讲主要介绍了进程2的创建。进程2是由进程1fork出来的。所以大体上就是copy了一下进程1的内容，并进行一些修改。

进程2和进程1的主要不同点有：

1. 进程 2 与进程 1 几乎完全一样，只不过进程 2 通过 close 和 open 操作，将原来进程 1 的指向标准输入的 0 号文件描述符，重新指向了 /etc/rc 文件。仅仅是将 0 号文件描述符重新指向了 /etc/rc 文件，其他的没啥区别。
2.  进程2通过execve 函数调用，使自己摇身一变，成为 /bin/sh 程序继续运行
3. 注意此时，进程2还是使用的同一个tty文件描述符，即进程2和进程1在一个tty里面运行。

# 第三十四回

 这一讲主要介绍了 execve 函数调用，使进程2摇身一变，成为 /bin/sh 程序继续运行

 execve函数的主要功能为：
 1. 加载文件
 2. 调整内存
 3. 开始执行

 加载文件部分：
 1. 根据文件名 /bin/sh 获取 inode
 2. 根据 inode 读取文件第一块数据（1024KB），就是读取了文件（/bin/sh）第一个块
 3. 解析这 1KB 的数据为 exec 结构（就是将关键的内容，存放到exec结构体中，比如代码从哪开始，数据多长，代码区多长等）

 读取完文件后，要判断下这个文件的类型

调整内存：
1. 我们执行 /bin/sh 时，还给它传了 argc 和 envp 参数
2. 每个进程的参数表大小为 128K，在每个进程地址空间的最末端。参数表为 128K，就表示每个进程的线性地址空间的末端 128K，是为参数表保留的，目前这个 p 就指向了参数表的开始处（偏移 4 字节）。所以最终的 p 值被调整为了以每个进程的线性地址空间视角下的地址偏移

开始执行：
1. 设置 eip 和 esp，完成摇身一变，本质上就是，代码指针 eip 和栈指针 esp 指向了一个新的地方。
2. 代码指针 eip 决定了 CPU 将执行哪一段指令，栈指针 esp 决定了 CPU 压栈操作的位置，以及读取栈空间数据的位置，在高级语言视角下就是局部变量以及函数调用链的栈帧。
3. 所以这两行代码，第一行重新设置了代码指针 eip 的值，指向 /bin/sh 这个 a.out 格式文件的头结构 exec 中的 a_entry 字段，表示该程序的入口地址。 第二行重新设置了栈指针 esp 的值，指向了我们经过一路计算得到的 p，也就是图中 sp 的值。

# 第三十五回

主要介绍了缺页中断。

如果当前要访问的内存地址页表不存在，那么触发缺页中断。

缺页中断会执行：
1. 计算当前访问地址的页目录和页表位置。进行对齐，然后计算页内偏移量。
2. 找到空闲的一页内存，并将数据从硬盘中存入内存中。
3. 将虚拟地址和空闲页表，进行映射

execve 函数返回后，CPU 就跳转到 /bin/sh 程序的第一行开始执行，但由于跳转到的线性地址不存在，所以引发了今天我们讲的缺页中断，把硬盘里 /bin/sh 所需要的内容加载到了内存，此时缺页中断返回。

返回后，CPU 会再次尝试跳转到 0x8000000 这个线性地址，此时由于缺页中断的处理结果，使得该线性地址已有对应的页表进行映射，所以顺利地映射到了物理地址，也就是 /bin/sh 的代码部分（从硬盘加载过来的），那接下来就终于可以执行 /bin/sh 程序，也就是 shell 程序了。

# 第三十六回

这一讲主要介绍了shell程序的运行。shell 程序也仅仅是个程序而已，它的输出，它的输入，它的执行逻辑，是完全可以通过阅读程序源码来知道的，和一个普通的程序并没有任何区别。
 
总得来说，shell 程序就是个死循环，它永远不会自己退出，除非我们手动终止了这个 shell 进程。

在死循环里面，shell 就是不断读取（getcmd）我们用户输入的命令，创建一个新的进程（fork），在新进程里执行（runcmd）刚刚读取到的命令，最后等待（wait）进程退出，再次进入读取下一条命令的循环中。

runcmd函数里面有之前的excve命令，主要就是找到命令的文件，然后加载到内存。解析参数，然后开始执行命令的文件里写好的代码。

# 第三十七回

这个登陆画面就和我们 Linux 0.11 里讲的这个 shell 程序一样，已经可以说标志着操作系统启动完毕了，通过 shell 不断接受用户命令并执行命令的死循环过程中。

甚至在 Linux 0.11 里根本都找不到 shell 的源代码，说明 Linux 0.11 并没有认为 shell 是操作系统的一部分，它只是个普通的用户程序，和你在操作系统里自己写个 hello world 编译成 a.out 执行一样。在执行这个 shell 程序前已经可以认为操作系统启动完毕了。

操作系统就是初始化了一堆数据结构进行管理，并且提供了一揽子系统调用接口供上层的应用程序调用，仅此而已。再多做点事就是提供一些常用的用户程序，但这不是必须的。

我们先是建立了操作系统的一些最基本的环境与管理结构，然后由进 0 fork 出处于用户态执行的进程 1，进程 1 加载了文件系统并打开终端文件，紧接着就 fork 出了进程 2，进程 2 通过我们刚刚讲述的 execve 函数将自己替换成了 shell 程序。

# 第三十八回

这一讲介绍了由rc界面，进入tty的过程。

如果看代码的话，其实我们此时处于一个以 rc 为标准输入的 shell 程序。

就是 open 了 /etc/rc 然后 execve 了 /bin/sh 的这个程序，代码中标记为蓝色的部分。

shell 程序有个特点，就是如果标准输入为一个普通文件，比如 /etc/rc，那么文件读取后就会使得 shell 进程退出，如果是字符设备文件，比如由我们键盘输入的 /dev/tty0，则不会使 shell 进程退出。

这就使得标准输入为 /etc/rc 文件的 shell 进程在读取完 /etc/rc 这个文件并执行这个文件里的命令后，就退出了。

所以，这个 /etc/rc 文件可以写一些你觉得在正式启动大死循环的 shell 程序之前，要做的一些事，比如启动一个登陆程序，让用户输入用户名和密码。

只不过它的标准输入被替换成了 tty0，也就是接受我们键盘的输入。

这个 shell 程序不会退出，它会不断接受我们键盘输入的命令，然后通过 fork+execve 函数执行我们的命令，这在上一回讲过了。

当然，如果这个 shell 进程也退出了，那么操作系统也不会跳出这个大循环，而是继续重试。

整个操作系统到此为止，看起来就是这个样子。

# 第三十九回

这一部分介绍shell命令是如何解析执行，然后返回结果的。

本回介绍的是，当我们在键盘上敲击命令，是如何显示在屏幕上的.

当我们敲下键盘，然后控制台上会显示我们敲下的东西时，这里面涉及到什么原理呢？ `cat info.txt | wc -l`

核心点就是三个队列 read_q，secondary 以及 write_q。

其中 read_q 是键盘按下按键后，进入到键盘中断处理程序 keyboard_interrupt 里，最终通过 put_queue 函数字符放入 read_q 这个队列。

secondary 是 read_q 队列里的未处理字符，通过 copy_to_cooked 函数，经过一定的 termios (termios 是定义了终端的各种模式，包括读模式、写模式、控制模式,或者将字符转换成小写等) 规范处理后，将处理过后的字符放入 secondary。（处理过后的字符就是成"熟"的字符，所以叫 cooked，是不是很形象？）

然后，进程通过 tty_read 从 secondary 里读字符，通过 tty_write 将字符写入 write_q，最终 write_q 中的字符可以通过 con_write 这个控制台写函数，将字符打印在显示器上。

这就完成了从键盘输入到显示器输出的一个循环，也就是本回所讲述的内容。

好了，现在我们已经成功做到可以把这样一个字符串输入并回显在显示器上了。

# 第四十回


# 第四十一回