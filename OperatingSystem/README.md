# 目录
<!--ts-->
* [目录](#目录)
* [操作系统](#操作系统)
* [第一回](#第一回)
* [第二回](#第二回)
* [第三回](#第三回)
* [第四回](#第四回)
* [第五回](#第五回)
* [第六回](#第六回)
* [第七回](#第七回)

<!-- Added by: zwl, at: Wed Mar  9 20:29:17 CST 2022 -->

<!--te-->
# 操作系统

推荐教程：
- [哈工大操作系统 [MOOC]](https://www.icourse163.org/learn/HIT-1002531008?tid=1450346461#/learn/content?type=detail&id=1214728532&cid=1218670721&replay=true) 
- [哈工大操作系统
  [bilibili]](https://www.bilibili.com/video/BV1d4411v7u7?from=search&seid=8612787840369428117&spm_id_from=333.337.0.0) 
- [品读操作系统源码](https://github.com/sunym1993/flash-linux0.11-talk#%E5%B7%B2%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0) 


[【↥ back to top】](#目录)
# 第一回

在电脑开机到启动，经历了下面几个过程：
- 开机的时候，电脑主板上写死的BIOS(Basic Input Output System)程序会自动运行
- BIOS会将存储在硬盘上的操作系统，拷贝到内存的0x7c00，这个地址由电脑架构决定
- 电脑从该地址开始，一行一行执行命令

> 注意：
>
> 1. 操作系统肯定是先存储在硬盘中的
>
> 2. 代码执行肯定是在内容中的，并且执行方式为**取指执行** 
>
> 3. 该部分bootsect.s 汇编文件控制
>
> 4. ds寄存器的值为0x07c0，之后的代码，段基地址都要先左移动4位，这就变成了0x7c00,
> 所以之后的9000->90000都是这个原理,
> ds是段基寄存器，后面的地址都是在这个基础上偏移

> 为什么要左移4位呢？
>
> 因为此时x86为16位实模式, 为了能访问到20位的地址线，所以要左移4位

[reference](https://mp.weixin.qq.com/s/LIsqRX51W7d_yw-HN-s2DA) 


[【↥ back to top】](#目录)
# 第二回

从上回开始，开机后，操作系统开始执行命令了，命令如下：
- 将各个寄存器赋值[ds:0x07c0, es:0x9000, cx:256, si:0, di:0]
- 将ds开始的512字节(cx * 2)的内容，复制到0x90000处(为啥是512字节？`rep movw`
  命令表示复制一个字，每个字是16位，也就是2字节，重复该命令256次，)
- 程序 跳转至go标记处，也就是0x9000 + go标记的偏移地址开始执行剩下的代码
可以看到，第二回的代码就是将程序移动了个位置，将内容腾出空间来了

> 内存复制是从(ds:si --> es:di)

[reference](https://mp.weixin.qq.com/s/U-txDYt0YqLh5EeFOcB4NQ) 


[【↥ back to top】](#目录)
# 第三回

在执行代码之前，因为所有的工作都是在内存中执行的，为了方便管理，要对内存的使用进行一个规划：
- 给寄存器赋值(cs:0x9000, ds:0x9000, ss:0x9000, es:0x9000, ip:0x9000, sp:0xFF00)
- 前面我们将代码挪动到了0x90000处，栈由指针控制，所以栈顶为0x9FF00

现在内存中寄存器布局位置如下：

```
栈顶 ss:sp   -->   0x9FF00 |    |
                           |    |
                           |    |
                           |    |
                           |    |
ss,ds,cs,ip,es --> 0x90000 |    |
```

> 1. 内存中很重要的三个片段: cs为代码段，ds为数据段，ss堆栈段
> ss为堆栈段，es为附加段，ip为指令指针
>
> 2. cs + ip 控制代码访问, ss + sp控制栈顶访问， ds控制数据访问， es先不用理会
>
> 3. 栈的位置要远远大于代码的位置0x90000，所以设置为0x9FF00,
>    保证栈向下发展不会碰到其他段

> 1. 该部分就是将各个寄存器设置好了值
> 2.
> 再抽象点就是：该部分给如何访问代码，如何访问数据，如何访问栈进行了内存的初步规划

[reference](https://mp.weixin.qq.com/s/90QBJ-lP_-du2qQJxNF-Fw) 


总结下：该部分 `bootsect.s`
代码，所做的就是对内存做了初步规划，同时将操作系统，从硬盘中，搬到了内存中


[【↥ back to top】](#目录)
# 第四回

上面代码中，代码已经做了：
1. 将启动部分代码从硬盘中第一扇区搬到了内存中
2. 对内存的使用做了初步的规划，代码段，数据段，堆栈段

**注意**: 此时我们还在`bootsect.s`文件中

接下来还有操作系统的其他代码，要从硬盘搬到内存中:
- 程序发起中断, 执行其他代码,
  该代码会将2-5一共4个扇区的代码，拷贝到0x90200往后的部分，因为每个扇区都是512字节，刚好是200表示，0x90400这样一直往后拷入代码。
- 从第6个扇区开始的代码，拷贝到内存的0x10000处
- 最后跳转到0x90200代码处开始执行

重新梳理下：
- 0x90000-0x90200部分代码，装的是bootsect.s，即第1扇区的代码
- 0x90200-0x90A00部分，装的是setup.s部分，即第2-5扇区
- 0x10000往后，装的是第6往后240个扇区的代码，为system

> 中断是什么？
>
> 中断包括三种：
>
> 1）I/O设备的中断 
>
> 2）程序异常的中断 
>
> 3）INT信号的中断
>
> 前两种中断都是硬件的中断, 如鼠标点击，键盘输入为1)中断, 寄存器中的计算错误为2）中断，最后一种为软件的中断，如SIG中断，9表示HANP信号，相当于kill -s 9 <pid>
>
> [中断参考文章](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247498208&idx=1&sn=b784f8b4e627ebd1bfb9810d194fdb80&chksm=c2c5834df5b20a5bdee331002bfc61c90eb468da325bf67abeef780c303a9f51c8543e1a5981&scene=21#wechat_redirect) 


[【↥ back to top】](#目录)
# 第五回

前面讲完了`bootsect.s`部分的代码，现在可以进入到`setup.s`，该部分代码做了如下几件事:
- 通过各种中断调用(其实就相当于调用函数，然后将获取的值，存储到寄存器中),
  获取电脑各种硬件的值，如显存大小，内存大小等
- 将这些信息存储到0x90000的位置
- 然后将0x10000部分260个扇区的代码(即system部分，这部分代码相当于整个操作系统文件编译出来的)， 复制移动到内存地址为0开始的部分

于是，现在整个内存的规划如下：

```
栈顶 0x9FF00         |     |
                     |     |
                     |     |
setup 0x90200        |     | <--  setup.s就是将电脑信息获取并存储，同时对内存进行了管理
                     |     |
电脑信息存储 0x90000 |     |
                     |     |
   0x80000           |     | <--  到这个部分都是存储的操作系统，刚好512K，大约512 * 1024 字节
   操作系统          |     |
   0x0               |     |
```

[reference](https://mp.weixin.qq.com/s/5s_nmrWRZbA_4mkNKOQ2Cg) 


[【↥ back to top】](#目录)
# 第六回

这一讲介绍了intel芯片的一个历史遗留问题，前面我们知道`ds`
为段基寄存器，其与内存中地址的转换方法为**段基地址左移4位，然后与偏移地址相加，最后获得实际的地址** 

上面这种计算方式为：实模式，也就是16位实模式下的CPU，然而现在很多CPU都支持32位或者64位

当切换到保护模式下后，内存地址的计算方式就不同: 段选择子 --> 段描述符索引 -->
查表(gdt全局描述符表) --> 获得段描述符 --> 段基地址 --> 与偏移地址相加，获得实际物理地址

> 总的来说，就是ds寄存器，在保护模式下，里面存储的不叫段基址，而叫段选择子，段选择子中存储着**段描述符索引**
> 既然是索引，那么就可以查表，获得对应的值了，然后从存储在内存中的全局描述符表中，查找到段描述符。段描述符中含有段基地址，也就是实模式下的ds存储的段基地址，最后与偏移地址相加。
> 所以，保护模式下，最后也是为了获得段基地址，只不过多了很多中间步骤.

这一讲就是介绍了在进入保护模式的时候，内存地址的查询变复杂了，设置了一个中间层，现在需要查表(gdt)才能获得真实地址了

```
栈顶 0x9FF00         |     |
                     |     | <--  idt地址(中断描述表 也存储在setup这部分中)
                     |     | <--  gdt地址(全局描述表 存储在setup这部分地址中)
setup 0x90200        |     | <--  setup.s就是将电脑信息获取并存储，同时对内存进行了管理
                     |     |
电脑信息存储 0x90000 |     |
                     |     |
   0x80000           |     | <--  到这个部分都是存储的操作系统，刚好512K，大约512 * 1024 字节
   操作系统          |     |
   0x0               |     |
```

> 什么是实模式？最开始，cpu都是直接操作内存地址，这种叫做实模式，否则叫保护模式

[reference](https://mp.weixin.qq.com/s/p1a6QxYZyMpJF__uBSE1Kg) 


[【↥ back to top】](#目录)
# 第七回


[reference](https://mp.weixin.qq.com/s/S5zarr9BmLhUHAmdmeNypA) 
