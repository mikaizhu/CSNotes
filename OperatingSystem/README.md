# 目录
<!--ts-->
* [目录](#目录)
* [操作系统](#操作系统)
* [第一回](#第一回)
* [第二回](#第二回)
* [第三回](#第三回)
* [第四回](#第四回)
* [第五回](#第五回)
* [第六回](#第六回)
* [第七回](#第七回)

<!-- Added by: zwl, at: Thu Jul 14 18:50:09 CST 2022 -->

<!--te-->
# 操作系统

推荐教程：
- [哈工大操作系统 [MOOC]](https://www.icourse163.org/learn/HIT-1002531008?tid=1450346461#/learn/content?type=detail&id=1214728532&cid=1218670721&replay=true) 
- [哈工大操作系统
  [bilibili]](https://www.bilibili.com/video/BV1d4411v7u7?from=search&seid=8612787840369428117&spm_id_from=333.337.0.0) 
- [品读操作系统源码](https://github.com/sunym1993/flash-linux0.11-talk#%E5%B7%B2%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0) 


[【↥ back to top】](#目录)
# 第一回

在电脑开机到启动，经历了下面几个过程：
- 开机的时候，电脑主板上写死的BIOS(Basic Input Output System)程序会自动运行
- BIOS会将存储在硬盘上的操作系统，拷贝到内存的0x7c00，这个地址由电脑架构决定
- 电脑从该地址开始，一行一行执行命令

> 注意：
>
> 1. 操作系统肯定是先存储在硬盘中的
>
> 2. 代码执行肯定是在内容中的，并且执行方式为**取指执行** 
>
> 3. 该部分bootsect.s 汇编文件控制
>
> 4. ds寄存器的值为0x07c0，之后的代码，段基地址都要先左移动4位，这就变成了0x7c00,
> 所以之后的9000->90000都是这个原理,
> ds是段基寄存器，后面的地址都是在这个基础上偏移

> 为什么要左移4位呢？
>
> 因为此时x86为16位实模式, 为了能访问到20位的地址线，所以要左移4位

[reference](https://mp.weixin.qq.com/s/LIsqRX51W7d_yw-HN-s2DA) 


[【↥ back to top】](#目录)
# 第二回

从上回开始，开机后，操作系统开始执行命令了，命令如下：
- 将各个寄存器赋值[ds:0x07c0, es:0x9000, cx:256, si:0, di:0]
- 将ds开始的512字节(cx * 2)的内容，复制到0x90000处(为啥是512字节？`rep movw`
  命令表示复制一个字，每个字是16位，也就是2字节，重复该命令256次，)
- 程序 跳转至go标记处，也就是0x9000 + go标记的偏移地址开始执行剩下的代码
可以看到，第二回的代码就是将程序移动了个位置，将内容腾出空间来了

> 内存复制是从(ds:si --> es:di)

[reference](https://mp.weixin.qq.com/s/U-txDYt0YqLh5EeFOcB4NQ) 


[【↥ back to top】](#目录)
# 第三回

在执行代码之前，因为所有的工作都是在内存中执行的，为了方便管理，要对内存的使用进行一个规划：
- 给寄存器赋值(cs:0x9000, ds:0x9000, ss:0x9000, es:0x9000, ip:0x9000, sp:0xFF00)
- 前面我们将代码挪动到了0x90000处，栈由指针控制，所以栈顶为0x9FF00

现在内存中寄存器布局位置如下：

```
栈顶 ss:sp   -->   0x9FF00 |    |
                           |    |
                           |    |
                           |    |
                           |    |
ss,ds,cs,ip,es --> 0x90000 |    |
```

> 1. 内存中很重要的三个片段: cs为代码段，ds为数据段，ss堆栈段, es为附加段，ip为指令指针
>
> 2. cs + ip 控制代码访问, ss + sp控制栈顶访问， ds控制数据访问， es先不用理会
>
> 3. 栈的位置要远远大于代码的位置0x90000，所以设置为0x9FF00,
>    保证栈向下发展不会碰到其他段

> 1. 该部分就是将各个寄存器设置好了值
> 2. 再抽象点就是：该部分给如何访问代码，如何访问数据，如何访问栈进行了内存的初步规划

[reference](https://mp.weixin.qq.com/s/90QBJ-lP_-du2qQJxNF-Fw) 


所以，该部分 `bootsect.s`代码，所做的就是对内存做了初步规划


[【↥ back to top】](#目录)
# 第四回

上面代码中，代码已经做了：
1. 将启动部分代码从硬盘中第一扇区搬到了内存中
2. 对内存的使用做了初步的规划，代码段，数据段，堆栈段

**注意**: 此时我们还在`bootsect.s`文件中

接下来还有操作系统的其他代码，要从硬盘搬到内存中:
- 程序发起中断, 执行其他代码,
  该代码会将2-5一共4个扇区的代码，拷贝到0x90200往后的部分，因为每个扇区都是512字节，刚好是200表示，0x90400这样一直往后拷入代码。
- 从第6个扇区开始的代码，拷贝到内存的0x10000处
- 最后跳转到0x90200代码处开始执行

重新梳理下：
- 0x90000-0x90200部分代码，装的是bootsect.s，即第1扇区的代码
- 0x90200-0x90A00部分，装的是setup.s部分，即第2-5扇区
- 0x10000往后，装的是第6往后240个扇区的代码，为system

> 中断是什么？
>
> 中断包括三种：
>
> 1）I/O设备的中断 
>
> 2）程序异常的中断 
>
> 3）INT信号的中断
>
> 前两种中断都是硬件的中断, 如鼠标点击，键盘输入为1)中断, 寄存器中的计算错误为2）中断，最后一种为软件的中断，如SIG中断，9表示HANP信号，相当于kill -s 9 <pid>
>
> [中断参考文章](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247498208&idx=1&sn=b784f8b4e627ebd1bfb9810d194fdb80&chksm=c2c5834df5b20a5bdee331002bfc61c90eb468da325bf67abeef780c303a9f51c8543e1a5981&scene=21#wechat_redirect) 

**总结下前面部分都是`bootsect.s` 文件的工作内容，工作内容如下**:
1. 刚启动的时候，刻入在板子上的BIOS代码，会将硬盘中的第一扇区代码，寸到内存中，然后开始执行(只要我们将bootsect.s代码，编译到这部分地址即可)
2. 对内存进行初步规划
3. 将setup部分代码，存储到内存中
4. 将操作系统代码，存储到内存中，3.4部分说明就是将剩下的代码，也从硬盘中搬运到内存中


[【↥ back to top】](#目录)
# 第五回

前面讲完了`bootsect.s`部分的代码，现在可以进入到`setup.s`，该部分代码做了如下几件事:
- 通过各种中断调用(其实就相当于调用函数，然后将获取的值，存储到寄存器中),
  获取电脑各种硬件的值，如显存大小，内存大小等
- 将这些信息存储到0x90000的位置
- 然后将0x10000部分260个扇区的代码(即system部分，这部分代码相当于整个操作系统文件编译出来的)， 复制移动到内存地址为0开始的部分

于是，现在整个内存的规划如下：

```
栈顶 0x9FF00         |     |
                     |     |
                     |     |
setup 0x90200        |     | <--  setup.s就是将电脑信息获取并存储，同时对内存进行了管理
                     |     |
电脑信息存储 0x90000 |     |
                     |     |
   0x80000           |     | <--  到这个部分都是存储的操作系统，刚好512K，大约512 * 1024 字节
   操作系统          |     |
   0x0               |     |
```

[reference](https://mp.weixin.qq.com/s/5s_nmrWRZbA_4mkNKOQ2Cg) 


[【↥ back to top】](#目录)
# 第六回

这一讲介绍了intel芯片的一个历史遗留问题，前面我们知道`ds`
为段基寄存器，其与内存中地址的转换方法为**段基地址左移4位，然后与偏移地址相加，最后获得实际的地址** 

上面这种计算方式为：实模式，也就是16位实模式下的CPU，然而现在很多CPU都支持32位或者64位

当切换到保护模式下后，内存地址的计算方式就不同: 段选择子 --> 段描述符索引 -->
查表(gdt全局描述符表) --> 获得段描述符 --> 段基地址 --> 与偏移地址相加，获得实际物理地址

> 总的来说，就是ds寄存器，在保护模式下，里面存储的不叫段基址，而叫段选择子，段选择子中存储着**段描述符索引**
> 既然是索引，那么就可以查表，获得对应的值了，然后从存储在内存中的全局描述符表中，查找到段描述符。段描述符中含有段基地址，也就是实模式下的ds存储的段基地址，最后与偏移地址相加。
> 所以，保护模式下，最后也是为了获得段基地址，只不过多了很多中间步骤.

这一讲就是介绍了在进入保护模式的时候，内存地址的查询变复杂了，设置了一个中间层，现在需要查表(gdt)才能获得真实地址了

```
栈顶 0x9FF00         |     |
                     |     | <--  idt地址(中断描述表 也存储在setup这部分中)
                     |     | <--  gdt地址(全局描述表 存储在setup这部分地址中)
setup 0x90200        |     | <--  setup.s就是将电脑信息获取并存储，同时对内存进行了管理
                     |     |
电脑信息存储 0x90000   |     |
                     |     |
   0x80000           |     | <--  到这个部分都是存储的操作系统，刚好512K，大约512 * 1024 字节
   操作系统           |     |
   0x0               |     |
```

> 什么是实模式？最开始，cpu都是直接操作内存地址，这种叫做实模式，否则叫保护模式
> 保护模式可以给这个代码段设置权限，比如可读，可写，不可读等
> 这部分还设置了中断描述符表idt, 中断代码查询，然后跳转执行
> gdt分为代码段和数据段描述符

[reference](https://mp.weixin.qq.com/s/p1a6QxYZyMpJF__uBSE1Kg) 


[【↥ back to top】](#目录)
# 第七回

进入保护模式很简单，直接将cr0寄存器中的地位设置为1，计算机就进入了保护模式。

保护模式下，寻址都是通过查看寄存器中段选择子中的段描述符，然后通过段描述符，去内存中的全局描述符中查找对应的段基址，查看发现这是个可以读可以执行的地址，然后跳转到这个位置，加上偏移，最后执行。

这部分最后跳转到内存地址为0的位置，开始执行head.s，准备进入操作系统。

[reference](https://mp.weixin.qq.com/s/S5zarr9BmLhUHAmdmeNypA) 

# 第八回

这一讲就是再设置一遍gdt和idt，将两个描述符的位置，从之前的setup里面，迁移到了system里面，因为后面上面的其他内存会被覆盖掉。

同时给每个中断，都设置了一个默认的指向函数，ignore函数，到时候会替换这个指向。

# 第九回

这一回就是通过设置寄存器的标志位，手动开启分页操作。

开启分页操作前，我们是通过分段的方式，来进行物理地址的转换。

开启分页操作后，通过段获取的是虚拟内存地址。通过查询页表后，才能转换成物理地址。

CPU 在看到我们给出的内存地址后，首先把线性地址被拆分成, 高 10 位：中间 10 位：后 12 位,  高 10 位负责在页目录表中找到一个页目录项，这个页目录项的值加上中间 10 位拼接后的地址去页表中去寻找一个页表项，这个页表项的值，再加上后 12 位偏移地址，就是最终的物理地址。

而这一切的操作，都由计算机的一个硬件叫 MMU，中文名字叫内存管理单元，有时也叫 PMMU，分页内存管理单元。由这个部件来负责将虚拟地址转换为物理地址。

# 第十回

就是将main函数的代码，压入到栈中，然后让cpu去执行

# 第十二回

开始进入main函数，最开始还是内存管理，设置了主内存的开始末尾位置，以及缓冲区的位置。

# 第十三回

就是设置了一个数组来进行内存管理(mem_map函数)，将内存进行分页，每页的大小为4k，所以数组的每个元素表示4k内存.

# 第十四回

这一回主要介绍了什么时候键盘可以工作，键盘本质上是中断，这里代码重新写入了中断，并一项项添加进idt中，其中键盘的中断，是后面定义的，有部分中断为硬件代码初始化的时候创建的.

# 第十五回

操作系统是如何读取硬盘的, 在进入main函数开始的时候，会初始化一个request请求的结构体，这个结构体就是一个列表，如果有进程需要和内存通信，最后就会形成一个链表，这个链表记录了所有请求.最后操作系统会处理所有的请求，清空链表

# 第十六回

就是介绍了下如何向屏幕写入数据。首先我们要知道，内存中的一部分空间，是映射的显存。只要往内存这部分写入数据，就是往显存上写入数据，然后屏幕上就会显示内容。

关键的一点就是光标位置。要确定光标位置，需要三个参数。x，y，pos(pos是根据x和y计算出来的显存的位置, 所以我们还可以设置换行操作)，x表示光标所在行号，y表示光标所在列号，pos表示要写入的内存地址。显存有两个部分，第一个部分表示要写入的内容，第二个部分为内容的颜色。如果要做到向屏幕显示内容，先要获取光标位置，然后触发中断，将键盘中断获取的内容，填入到光标的内存中，然后光标的内存进行移动。

甚至我们还可以做到屏幕滚动。其实就是将显存内容进行复制。

# 第十七回

操作系统是如何设置时间的？以前还没有网络的时候，电脑是如何获取时间的。本质上还是操作系统写了一个和外部硬件通信的函数，从外界获取，并计算出时间。获取的方式主要为。每个硬件都有自己的手册，说明了每个端口要设置什么参数，如何读取。我们只要按照手册上的参数设置就好了。操作系统就是和外部的CMOS进行交互，获取到了当前时间。

# 第十八回

这一讲主要介绍了三个主要内容：
1. 往全局描述符gdt中加入了两个新的角色，TSS和LDT，其中LDT是局部描述符，里面有自己的数据段和代码段，以后用户进程都用自己的LDT，而TSS为任务状态段，保存的进程的上下文信息，内部为结构体，保存的各个寄存器的信息。用来帮助恢复上下文。这两个信息都是加入在全局描述符后面的。代码中先为0进程的创建，先添加了TSS和LDT，其他的初始化为空。

2. 创建了一个task struct数据结构（结构体）,用来保存每个进程的信息。类似于数组一样，并给第0个进程进行初始化，其他的进程设置为空，以后添加。

3. 设置了两个中断函数，时钟中断timer interrupt和system call系统调用中断。这两个中断非常重要，时钟中断是方便进程切换，利用外部的时钟信息，发起时钟中断，然后调用中断函数。系统调用是当系统想使用系统函数，就会触发该中断，从用户态切换到内核态。

# 第十九回

这里设置了缓存区的初始化。内存中有部分叫buffer memory，以后操作系统要和硬盘交互的时候，都会先和缓存区进行交互，判断数据是不是有了，如果有，就不用读取了。

管理的方式，是使用双链表，结构体中，含有两个部分，缓冲块和缓冲头，缓冲头有缓冲块的地址，缓冲块是存储数据的。缓冲头采用的是双链表的数据结构，同时指向缓冲块的地址。

但链表有个缺点，就是必须要每次都从头开始遍历。所以还构造一个hash table，当数据过来的时候，可以通过哈希值，看是不是有冲突，表示数据是不是已经有了。

# 第二十回

**看到最后，你会发现操作系统就是一个靠中断驱动的死循环而已，如果不发生任何中断，操作系统会一直在一个死循环里等待。换句话说，让操作系统工作的唯一方式，就是触发中断。**

这一回介绍了硬盘的初始化，简单来说只有三步：
1. 向硬盘写入数据，表示要进行什么操作
2. 新建一个硬盘中断函数, 硬盘中断触发，就会执行这个中断
3. 定义数据结构，来管理读取的数据

# 中期总结

[参考](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247500983&idx=1&sn=ad4c430823c975df97f13de3fbe8c66e&chksm=c2c5be1af5b2370cad4ce3218c5294feee4ae2e4d28804398c1dc8ac252c8dfafbe419ccf58c&cur_album_id=2123743679373688834&scene=189#wechat_redirect)

# 第二十一回

在前面进程初始化的时候，有一个task struct数据结构，这里定义了最开始的进程0，现在进入main函数后，从内核态切换到了用户态。然后执行fork命令，创建了第一个进程1，并且在里面执行init命令。init命令有很多代码，里面会创建进程2等。执行完init后，就会陷入循环，直到调用中断，操作系统才会做其他事。

# 第二十二回

mov_to_user_mode，特权级这块的检查细节非常繁琐，为了理解操作系统，我们只需要暂且记住如下一句话就好了：

数据访问只能高特权级访问低特权级，代码跳转只能同特权级跳转，要想实现特权级转换，可以通过中断和中断返回来实现。

# 第二十三回

进程调度的准备，如果要你设置一个进程调度，你会怎么操作。

为了保证上下文环境，需要保存各个寄存器的状态。

最主要的是下面几个。有表示状态的 state，表示剩余时间片的 counter，表示优先级的 priority，和表示上下文信息的 tss。其中tss中还有cr3，他是指向页表。意味着每个进程，都指向不同的页表，这样内存就不会冲突了。

# 第二十四回

罪魁祸首的，就是那个每 10ms 触发一次的定时器滴答。

而这个滴答将会给 CPU 产生一个时钟中断信号。

而这个中断信号会使 CPU 查找中断向量表，找到操作系统写好的一个时钟中断处理函数 do_timer。

do_timer 会首先将当前进程的 counter 变量 -1，如果 counter 此时仍然大于 0，则就此结束。

但如果 counter = 0 了，就开始进行进程的调度。

进程调度就是找到所有处于 RUNNABLE 状态的进程，并找到一个 counter 值最大的进程，把它丢进 switch_to 函数的入参里。

switch_to 这个终极函数，会保存当前进程上下文，恢复要跳转到的这个进程的上下文，同时使得 CPU 跳转到这个进程的偏移地址处。

接着，这个进程就舒舒服服地运行了起来，等待着下一次时钟中断的来临。

# 第二十五回

fork函数的调用过程，大致就是先从用户态切换到内核态。（通过中断0x80）

```
set_system_gate(0x80, &system_call);
```

看这个 system_call 的汇编代码，我们发现这么一行。

关键指令就是一个 0x80 号软中断的触发，int 80h。

其中还有一个 eax 寄存器里的参数是 __NR_fork，这也是个宏定义，值是 2。

```
_system_call:
    ...
    call [_sys_call_table + eax*4]
    ...
```

其中sys_call_table, 看到没，就是各种函数指针组成的一个数组，说白了就是个系统调用函数表。 从第零项开始数，第二项就是 sys_fork 函数

所以也可以直接调用 fork 这样的包装好的方法，而这个方法里本质也是 int 0x80 以及 eax 赋值而已。

那我们再多说两句，刚刚定义 fork 的系统调用模板函数时，用的是 syscall0，其实这个表示参数个数为 0，也就是 sys_fork 函数并不需要任何参数。

所以其实，在 unistd.h 头文件里，还定义了 syscall0 ~ syscall3 一共四个宏。

看都能看出来，其实 syscall1 就表示有一个参数，syscall2 就表示有两个参数。

整个流程：

fork->int 0x80|eax=2->system_call->syscall_table[2]->sys_fork;

# 第二十六回

这一讲主要介绍了sys_fork函数做了什么

其实就是调用了两个函数。

先是 find_empty_process，就是找到空闲的进程槽位。

然后 copy_process，就是复制进程。

就是先在这个数组中找一个空闲的位置，准备存一个新的进程的结构 task_struct，这个结构之前在 一个新进程的诞生（三）如果让你来设计进程调度 也简单说过了。

通过 copy_process 这个名字我们知道，就是复制原来的进程，也就是当前进程。

当前只有一个进程，就是数组中位置 0 处的 init_task.init，也就是零号进程，那自然就复制它咯。

find_empty_process主要做了以下：
1. 每个进程都是放在一个task数组中，进行管理的，每个数组都存放着一个结构体
2. 遍历task数组，查看当前元素是不是为空，不为空则继续查找当前pid是不是和使用的重复，重复则加一
3. 再使用一个for循环，判断当前taski是不是空，如果为空，则把新的进程结构体放入该位置, 并返回当前位置

由于我们现在只有 0 号进程，且 task[] 除了 0 号索引位置，其他地方都是空的，所以这个方法运行完，last_pid 就是 1，也就是新进程被分配的 pid 就是 1，然后即将要加入的 task[] 数组的索引位置，也是 1。

copy_process 方法

大部分都是 tss 结构的复制，以及一些无关紧要的分支

首先 get_free_page 会在主内存末端申请一个空闲页面, 那 get_free_page 这个函数就很简单了，就是遍历 mem_map[] 这个数组，找出值为零的项，就表示找到了空闲的一页内存。然后把该项置为 1，表示该页已经被使用。最后，算出这个页的内存起始地址，返回。然后，拿到的这个内存起始地址，就给了 task_struct 结构的 p。

首先将这个 p 记录在进程管理结构 task[] 中。
 
然后下一句 *p = *current 很简单，就是把当前进程，也就是 0 号进程的 task_struct 的全部值都复制给即将创建的进程 p，目前它们两者就完全一样了。嗯，这就附上值了，就完全复制之前的进程的 task_struct 而已，很粗暴。

然后，进程 1 和进程 0 目前是完全复制的关系，但有一些值是需要个性化处理的，下面的代码就是把这些不一样的值覆盖掉。不一样的值，一部分是 state，pid，counter 这种进程的元信息，另一部分是 tss 里面保存的各种寄存器的信息，即上下文。

# 第二十七回

主要讲得是copy_mem 函数;

那我们先看 LDT 表项的赋值，要说明白这个赋值的意义，得先回忆一下我们在 第九回 | Intel 内存管理两板斧：分段与分页 刚设置完页表时说过的问题。

因为有了页表的存在，所以多了线性地址空间的概念，即经过分段机制转化后，分页机制转化前的地址。

今后每个进程通过段基址的手段，分别在线性地址空间中占用 64M 的空间（暂不考虑段限长），且紧挨着。

经过以上的步骤，就通过分段的方式，将进程映射到了相互隔离的线性地址空间里，这就是段式管理。

原来进程 0 有一个页目录表和四个页表，将线性地址空间的 0-16M 原封不动映射到了物理地址空间的 0-16M。

那么新诞生的这个进程 2，也需要一套映射关系的页表，那我们看看这些页表是怎么建立的。这里需要一个copy_page_tables函数，这个函数比较复杂。做的工作主要是：
1. 前面利用分段机制，得到了虚拟地址。（分页机制开启后，分段后得到的，是虚拟地址）
2. 构建自己的页表，使得虚拟地址查表后，得到的是同样的物理地址

总之，最终的效果就是：

假设现在正在运行进程 0，代码中给出一个虚拟地址 0x03，由于进程 0 的 LDT 中代码段基址是 0，所以线性地址也是 0x03，最终由进程 0 页表映射到物理地址 0x03 处。

假设现在正在运行进程 1，代码中给出一个虚拟地址 0x03，由于进程 1 的 LDT 中代码段基址是 64M，所以线性地址是 64M + 3，最终由进程 1 页表映射到物理地址也同样是 0x03 处。

这样就实现了内存共享，虽然在分段机制上，每个进程都是64M分隔开来，但是通过分页后，可以操作共同的内存。但这样不就冲突了吗？后面可以实现缺页中断，使用的内存会被记录为可读状态。

总结下，copy_mem函数主要做了三个事：
1. LDT 的复制和改造，使得进程 0 和进程 1 分别映射到了不同的线性地址空间。
2. 页表的复制，使得进程 0 和进程 1 又从不同的线性地址空间，被映射到了相同的物理地址空间。
3. 最后，将新老进程的页表都变成只读状态，为后面写时复制的缺页中断做准备。

[参考](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247501866&idx=1&sn=64adec9179345945d095a1a1bdebcdac&chksm=c2c5b287f5b23b9175d8eacf7731b22823a576f78e14d8b93b2e8c9814bcb11076967d878a12&cur_album_id=2123743679373688834&scene=189#wechat_redirect)

# 第二十八回

这一讲主要总结了下，fork由0进程创建1进程的一个过程，后面1进程创建2进程的过程也是一样的。

首先fork通过0x80中断，调用system call函数，然后会进行查表，因为system call函数，会查找所有系统函数，都在一个table里面，然后调用第二个函数，对应是sys fork函数。这个函数里面有两个主要过程：
1. find empty process，从process table里面找空闲的位置
2. copy process函数，就是先复制当前进程的task struct给当前进程，然后修改下这个结构体里面的内容。（一般是修改寄存器里面的内容）同时还有修改数据段和代码段ldt，给每个进程分隔不同的线性地址（虚拟内存）。同时复制页表，并给进程2的tss页表，将新进程虚拟地址查询页表后，得到同样的物理地址。最后标记新进程为只读。

这里要主要：copy process函数在执行的时候，有个重要的细节就是，copy正在创建新进程的时候，一定要设置新进程的状态是无法选定的，因为里面还有很多没设置好，等设置好后，将状态修改为允许被调用。

[参考](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247501947&idx=1&sn=cb94f53c75d674d30fb4903778c74c08&chksm=c2c5b2d6f5b23bc027d9652d3e9949e55fd3b101beb87f6f80dd77d8233c0b51bede73edad46&cur_album_id=2123743679373688834&scene=189#wechat_redirect)

# 第二十九回

这一讲主要介绍了缺页中断：

页表当中有一位是表示读\写的，而 Linux 0.11 初始化时，把它设置为了 1，表示可读写。(即创建页表的时候，所有页表都是可读写的)

调用 fork 创建新进程时，原本页表和物理地址空间里的内容，都要进行复制, 但 fork 函数认为，复制物理地址空间里的内容，比较费时，所以姑且先只复制页表，物理地址空间的内容先不复制。

如果只有读操作，那就完全没有影响，复不复制物理地址空间里的内容就无所谓了，这就很赚。但如果有写操作，那就不得不把物理地址空间里的值复制一份，保证进程间的内存隔离。

fork的时候，两个进程都会指向同一个内存物理地址。并且映射的页表，都是只读状态。 那么此时，再次对这块物理地址空间进行写操作时，就不允许了。 但不允许并不是真的不允许，Intel 会触发一个缺页中断，具体是 0x14 号中断，中断处理程序里边怎么处理，那就由 Linux 源码自由发挥了。

假如是进程 2 写的。

显然此时这个物理空间被引用了大于 1 次，所以要复制页面。 并且更改页面只读属性为可读写。

```
new_page=get_free_page()；
*table_entry = new_page | 7;
```

那此时如果进程 1 再写, 那么引用次数就等于 1 了，只需要更改下页属性即可，不用进行页面复制操作。

```
if (mem_map[MAP_NR(old_page)]==1) ...
```

[参考](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502033&idx=1&sn=1acfd8b7f4c805906ecd51c33d0010eb&chksm=c2c5b27cf5b23b6a41051c7f93407afc97094a4b0a36ea050616778f4d072f074602f98983b2&cur_album_id=2123743679373688834&scene=189#wechat_redirect)
